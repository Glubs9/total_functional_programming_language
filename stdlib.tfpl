/* misc data definitions (other definitions exist in their given sections) */
data pair = cons[a, b];
data maybe = just[a] | nothing;

/* misc combinators, not too many cause higher order functions are not supported */
id(a) = a;
absurd{} = !;

/* boolean functions */
data bool = true | false;

not(true) = false;
not(false) = true;

and(false, a) = false; /* doesn't type check but it's whatever */
and(true, true) = true;
and(true, false) = false;

or(true, a) = true;
or(false, true) = true;
or(false, false) = false;

xor(a, b) = and(or(a,b), not(and(a,b)));
nand(a, b) = not(and(a,b));

if(true, a, b) = a; /* maybe not works with non-prim? also very unoptimized for primitive. Change later */
if(false, a, b) = b;

/* number functions */
data num = s[num] | 0;

plus(0, b) = b;
plus(s[a], b) = s[plus(a, b)];

multiply(0, b) = 0;
multiply(s[a], b) = plus(b, multiply(a, b));

power(0, b) = s[0];
power(s[a], b) = multiply(a, power(a, b));

zero() = 0;

pred(0) = zero();
pred(s[a]) = a;

pred_proj(a,b,c) = pred(proj_1(a,b,c));
minus(0,x) = id(x);
minus(s[n],x) = pred_proj(n,minus(n,x),x);

/* ackermann not too practical but I wanted an example of a non-primitive function */
ack{0, n} = s[n];
ack{s[m], 0} = ack{m, s[0]};
ack{s[m], s[n]} = ack{m, ack{s[m], n}};

lt(0, 0) = false;
lt(0, a) = true;
lt(s[a], s[b]) = lt(a, b);
lt(s[a], 0) = false;

/* list functions */
data list = list[a,list] | end;

head(end) = end;
head(list[a,b]) = a;
tail(end) = end;
tail(list[a,b]) = b;

