/* misc data definitions (other definitions exist in their given sections) */
data pair = cons[a, b];
data maybe = just[a] | nothing;

/* misc combinators, not too many cause higher order functions are not supported */
id(a) = a;

/* boolean functions */
data bool = true | false;

not(true) = false;
not(false) = true;

and(false, a) = false; /* doesn't type check but it's whatever */
and(true, true) = true;
and(true, false) = false;

or(true, a) = true;
or(false, true) = true;
or(false, false) = false;

xor(a, b) = and(or(a,b), not(and(a,b)));
nand(a, b) = not(and(a,b));
impl(a, b) = not(and(a, not(b)));/* implies */

if(true, a, b) = a; /* maybe not works with non-prim? also very unoptimized for primitive. Change later */
if(false, a, b) = b;

beq(a, b) = not(xor(a,b)); /* boolean equals */

/* number functions */
data num = s[num] | 0;

plus(0, b) = b;
plus(s[a], b) = s[plus(a, b)];

multiply(0, b) = 0;
multiply(s[a], b) = plus(b, multiply(a, b));

power(0, b) = s[0];
power(s[a], b) = multiply(a, power(a, b));

zero() = 0;

pred(0) = zero();
pred(s[a]) = a;

pred_proj(a,b,c) = pred(proj_1(a,b,c));
minus(0,x) = id(x);
minus(s[n],x) = pred_proj(n,minus(n,x),x);

/* ackermann not too practical but I wanted an example of a non-primitive function */
ack{0, n} = s[n];
ack{s[m], 0} = ack{m, s[0]};
ack{s[m], s[n]} = ack{m, ack{s[m], n}};

/* comparisons */
/* abbreviations used for comparisons. neq == number equals et cetera */
neq(0, 0) = true; 
neq(0, s[a]) = false;
neq(s[a], 0) = false;
neq(s[a], s[b]) = neq(a, b);

lt(0, 0) = false;
lt(0, s[b]) = true;
lt(s[a], 0) = false;
lt(s[a], s[b]) = lt(a, b);

gt(0, 0) = false;
gt(0, s[b]) = false;
gt(s[a], 0) = true;
gt(s[a], s[b]) = gt(a, b);

/* lte = less than or equal */
lte(a,b) = not(lt(a,b));
gte(a,b) = not(lt(a,b));

/* list functions */
data list = list[a,list] | end;

head(end) = end;
head(list[a,b]) = a;
tail(end) = end;
tail(list[a,b]) = b;

leq(end, end) = true; /* list equals */
leq(list[_, __], end) = false;
leq(end, list[_, __]) = false;
leq(list[h1,t1], list[h2,t2]) = if(neq(h1,h2), leq(t1, t2), false);

sum(end) = 0; /* this stuff makes me feel like polymorphic type checking is important */
sum(list[n, tail]) = plus(n, sum(tail));

any(end) = false;
any(list[n, tail]) = if(n, true, any(tail)); /* not strictly a normal definition but cool tho */

all(end) = true;
all(list[n, tail]) = and(n, all(tail));

/* this has to be the slowest way to sort a list outside of bogosort. has to go through every
 * possibility and iterate down every single number ever comparison */
bubble_it(end) = end;
bubble_it(list[h,end]) = list[h,end];
bubble_it(list[a, list[b, t]]) = if(
	lt(a,b), 
	list[a, bubble_it(list[b, t])],
	list[b, bubble_it(list[a, t])]
);

/* bubble_sort is while loop so we have to make it non-prim */
/* let statement would double the speed but it requires more effort from me lol */
/* bubble sort doesn't work :( */
/* god this idea is falling apart */
bubble_sort{l} = if(leq(bubble_it(l), l), l, bubble_sort{print(bubble_it(l))});
