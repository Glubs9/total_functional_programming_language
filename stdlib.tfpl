data num = s[num] | 0;
data list = list[a,list] | end;
data pair = cons[a, b];
data bool = true | false;

/* misc combinators */
id(a) = a;

/* boolean functions */
not(true) = false;
not(false) = true;

and(false, a) = false; /* doesn't type check but it's whatever */
and(true, true) = true;
and(true, false) = false;

or(true, a) = true;
or(false, true) = true;
or(false, false) = false;

xor(a, b) = and(or(a,b), not(and(a,b)));

if(true, a, b) = a; /* maybe not works with non-prim? also very unoptimized for primitive. Change later */
if(false, a, b) = b;

/* number functions (re-write later) */
proj(a, b, c) = b;
s_proj(a, b, c) = s[proj(a,b,c)];
plus(0, b) = id(b);
plus(s[a], b) = s_proj(a, plus(a, b), b);

proj_1(a,b,c) = b;
proj_2(a,b,c) = c;
plus_proj(a,b,c) = plus(proj_1(a,b,c), proj_2(a,b,c));
ignore(b) = 0;
multiply(0, b) = ignore(b);
multiply(s[a], b) = plus_proj(a, multiply(a, b), b);

one(b) = s[0];
multiply_proj(a,b,c) = multiply(proj_1(a,b,c), proj_2(a,b,c));
power(0, b) = one(b);
power(s[a], b) = multiply_proj(a, power(a, b), b);

zero() = 0;
proj_3(a,b) = a;
pred(0) = zero();
pred(s[a]) = proj_3(a, pred(a));

pred_proj(a,b,c) = pred(proj_1(a,b,c));
minus(0,x) = id(x);
minus(s[n],x) = pred_proj(n,minus(n,x),x);

ack{0, n} = s[n];
ack{s[m], 0} = ack{m, s[0]};
ack{s[m], s[n]} = ack{m, ack{s[m], n}};

/* list functions */

head(end) = end;
head(list[a,b]) = a;
tail(end) = end;
tail(list[a,b]) = b;

