/* misc data definitions (other definitions exist in their given sections) */
data pair = cons[a, b];
data maybe = just[a] | nothing;
data unit = unit;

/* misc combinators, not too many cause higher order functions are not supported. also not that useful */
id(a) = a;
const(a,b) = a;
ignore(a,b) = b;

INFINITE{a} = INFINITE{a}; /* not too useful. good for showing off the integration though */

/* boolean functions */
data bool = true | false;

not(true) = false;
not(false) = true;

and(false, a) = false; /* doesn't type check but it's whatever */
and(true, true) = true;
and(true, false) = false;

or(true, a) = true;
or(false, true) = true;
or(false, false) = false;

xor(a, b) = and(or(a,b), not(and(a,b)));
nand(a, b) = not(and(a,b));
impl(a, b) = not(and(a, not(b)));/* implies */

if(true, a, b) = a; /* maybe not works with non-prim? also very unoptimized for primitive. Change later */
if(false, a, b) = b;

beq(a, b) = not(xor(a,b)); /* boolean equals */

/* number functions */
data num = s[num] | 0;

plus(0, b) = b;
plus(s[a], b) = s[plus(a, b)];

multiply(0, b) = 0;
multiply(s[a], b) = plus(b, multiply(a, b));

power(0, b) = s[0];
power(s[a], b) = multiply(a, power(a, b));

zero() = 0;

pred(0) = zero();
pred(s[a]) = a;

minus(n,0) = n;
minus(n,s[x]) = pred(minus(n, x));

/* ackermann not too practical but I wanted an example of a non-primitive function */
ack{0, n} = s[n];
ack{s[m], 0} = ack{m, s[0]};
ack{s[m], s[n]} = ack{m, ack{s[m], n}};

/* comparisons */
/* abbreviations used for comparisons. neq == number equals et cetera */
neq(0, 0) = true; 
neq(0, s[a]) = false;
neq(s[a], 0) = false;
neq(s[a], s[b]) = neq(a, b);

lt(0, 0) = false;
lt(0, s[b]) = true;
lt(s[a], 0) = false;
lt(s[a], s[b]) = lt(a, b);

gt(0, 0) = false;
gt(0, s[b]) = false;
gt(s[a], 0) = true;
gt(s[a], s[b]) = gt(a, b);

/* lte = less than or equal */
lte(a,b) = not(lt(a,b));
gte(a,b) = not(lt(a,b));

/* list functions */
data list = list[a,list] | end;

leq(end, end) = true; /* list equals */
leq(list[_, __], end) = false;
leq(end, list[_, __]) = false;
leq(list[h1,t1], list[h2,t2]) = if(neq(h1,h2), leq(t1, t2), false);

sum(end) = 0; /* this stuff makes me feel like polymorphic type checking is important */
sum(list[n, tail]) = plus(n, sum(tail));

any(end) = false;
any(list[n, tail]) = if(n, true, any(tail)); /* not strictly a normal definition but cool tho */

all(end) = true;
all(list[n, tail]) = and(n, all(tail));

/* doesn't work :( */

/* this has to be the slowest way to sort a list outside of bogosort. has to go through every
 * possibility and iterate down every single number ever comparison */
bubble_it(end) = end;
bubble_it(list[h,end]) = list[h,end];
bubble_it(list[a, list[b, t]]) = if(
	lt(a,b), 
	list[a, bubble_it(list[b, t])],
	list[b, bubble_it(list[a, t])]
);

/* due to some issues with evalulation. I have added an extra primitive parameter to bubble sort
 * which acts as an upper bound for the amount of iterations. Later this will be made into a
 * non-prim function when if is fixed (it's also quite slow due to let not being implemented as well) */
	/* although the fact that we can chuck an upper bound on the iteration and have it become
	 * provably terminating is really cool. Kind of a real, more intuitive example of these kinds of 
	 * termination proofs */
	/* doesn't work :( */
/*
bubble_prim(l, 0) = l;
bubble_prim(l, s[a]) = if(
	leq(l, bubble_it(l)),
	l,
	bubble_prim(bubble_it(l), a)
);
*/

/* slow :( */
concat(end, l) = l;
concat(list[h,t], l) = list[h, concat(t, l)];

filter_less_than(end, n) = end;
filter_less_than(list[h,t], n) = if(
	lt(h, n),
	list[h, filter_less_than(t, n)],
	filter_less_than(t, n)
);

filter_greater_than(end, n) = end;
filter_greater_than(list[h,t], n) = if(
	gte(h, n),
	list[h, filter_greater_than(t, n)],
	filter_greater_than(t, n)
);

quick_sort{end} = end;
quick_sort{list[h, t]} = concat(
	quick_sort{filter_less_than(t, h)}, 
	list[h, quick_sort{filter_greater_than(t, h)}]
);
